{"ast":null,"code":"import { fromEvent, Observable } from 'rxjs';\nexport var ERR_CORDOVA_NOT_AVAILABLE = {\n  error: 'cordova_not_available'\n};\nexport var ERR_PLUGIN_NOT_INSTALLED = {\n  error: 'plugin_not_installed'\n};\nexport function getPromise(callback) {\n  var tryNativePromise = function () {\n    if (Promise) {\n      return new Promise(function (resolve, reject) {\n        callback(resolve, reject);\n      });\n    } else {\n      console.error('No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.');\n    }\n  };\n\n  if (typeof window !== 'undefined' && window.angular) {\n    var doc = window.document;\n    var injector = window.angular.element(doc.querySelector('[ng-app]') || doc.body).injector();\n\n    if (injector) {\n      var $q = injector.get('$q');\n      return $q(function (resolve, reject) {\n        callback(resolve, reject);\n      });\n    }\n\n    console.warn(\"Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.\");\n  }\n\n  return tryNativePromise();\n}\nexport function wrapPromise(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var pluginResult, rej;\n  var p = getPromise(function (resolve, reject) {\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return resolve(args);\n      }, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return reject(args);\n      });\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject);\n    }\n\n    rej = reject;\n  }); // Angular throws an error on unhandled rejection, but in this case we have already printed\n  // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n  // to error\n\n  if (pluginResult && pluginResult.error) {\n    p.catch(function () {});\n    typeof rej === 'function' && rej(pluginResult.error);\n  }\n\n  return p;\n}\n\nfunction wrapOtherPromise(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return getPromise(function (resolve, reject) {\n    var pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);\n\n    if (pluginResult) {\n      if (pluginResult.error) {\n        reject(pluginResult.error);\n      } else if (pluginResult.then) {\n        pluginResult.then(resolve).catch(reject);\n      }\n    } else {\n      reject({\n        error: 'unexpected_error'\n      });\n    }\n  });\n}\n\nfunction wrapObservable(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return new Observable(function (observer) {\n    var pluginResult;\n\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return observer.next(args);\n      }, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return observer.error(args);\n      });\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n    }\n\n    if (pluginResult && pluginResult.error) {\n      observer.error(pluginResult.error);\n      observer.complete();\n    }\n\n    return function () {\n      try {\n        if (opts.clearFunction) {\n          if (opts.clearWithArgs) {\n            return callCordovaPlugin(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n          }\n\n          return callCordovaPlugin(pluginObj, opts.clearFunction, []);\n        }\n      } catch (e) {\n        console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);\n        console.warn(e);\n      }\n    };\n  });\n}\n/**\n * Wrap the event with an observable\n * @private\n * @param event event name\n * @param element The element to attach the event listener to\n * @returns {Observable}\n */\n\n\nfunction wrapEventObservable(event, element) {\n  element = typeof window !== 'undefined' && element ? get(window, element) : element || (typeof window !== 'undefined' ? window : {});\n  return fromEvent(element, event);\n}\n\nexport function checkAvailability(plugin, methodName, pluginName) {\n  var pluginRef, pluginInstance, pluginPackage;\n\n  if (typeof plugin === 'string') {\n    pluginRef = plugin;\n  } else {\n    pluginRef = plugin.constructor.getPluginRef();\n    pluginName = plugin.constructor.getPluginName();\n    pluginPackage = plugin.constructor.getPluginInstallName();\n  }\n\n  pluginInstance = getPlugin(pluginRef);\n\n  if (!pluginInstance || !!methodName && typeof pluginInstance[methodName] === 'undefined') {\n    if (typeof window === 'undefined' || !window.cordova) {\n      cordovaWarn(pluginName, methodName);\n      return ERR_CORDOVA_NOT_AVAILABLE;\n    }\n\n    pluginWarn(pluginName, pluginPackage, methodName);\n    return ERR_PLUGIN_NOT_INSTALLED;\n  }\n\n  return true;\n}\n/**\n * Checks if _objectInstance exists and has the method/property\n * @private\n */\n\nexport function instanceAvailability(pluginObj, methodName) {\n  return pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== 'undefined');\n}\nexport function setIndex(args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  } // ignore resolve and reject in case sync\n\n\n  if (opts.sync) {\n    return args;\n  } // If the plugin method expects myMethod(success, err, options)\n\n\n  if (opts.callbackOrder === 'reverse') {\n    // Get those arguments in the order [resolve, reject, ...restOfArgs]\n    args.unshift(reject);\n    args.unshift(resolve);\n  } else if (opts.callbackStyle === 'node') {\n    args.push(function (err, result) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  } else if (opts.callbackStyle === 'object' && opts.successName && opts.errorName) {\n    var obj = {};\n    obj[opts.successName] = resolve;\n    obj[opts.errorName] = reject;\n    args.push(obj);\n  } else if (typeof opts.successIndex !== 'undefined' || typeof opts.errorIndex !== 'undefined') {\n    var setSuccessIndex = function () {\n      // If we've specified a success/error index\n      if (opts.successIndex > args.length) {\n        args[opts.successIndex] = resolve;\n      } else {\n        args.splice(opts.successIndex, 0, resolve);\n      }\n    };\n\n    var setErrorIndex = function () {\n      // We don't want that the reject cb gets spliced into the position of an optional argument that has not been\n      // defined and thus causing non expected behavior.\n      if (opts.errorIndex > args.length) {\n        args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index\n      } else {\n        args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array\n      }\n    };\n\n    if (opts.successIndex > opts.errorIndex) {\n      setErrorIndex();\n      setSuccessIndex();\n    } else {\n      setSuccessIndex();\n      setErrorIndex();\n    }\n  } else {\n    // Otherwise, let's tack them on to the end of the argument list\n    // which is 90% of cases\n    args.push(resolve);\n    args.push(reject);\n  }\n\n  return args;\n}\nexport function callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  } // Try to figure out where the success/error callbacks need to be bound\n  // to our promise resolve/reject handlers.\n\n\n  args = setIndex(args, opts, resolve, reject);\n  var availabilityCheck = checkAvailability(pluginObj, methodName);\n\n  if (availabilityCheck === true) {\n    var pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());\n    return pluginInstance[methodName].apply(pluginInstance, args);\n  } else {\n    return availabilityCheck;\n  }\n}\nexport function callInstance(pluginObj, methodName, args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  args = setIndex(args, opts, resolve, reject);\n\n  if (instanceAvailability(pluginObj, methodName)) {\n    return pluginObj._objectInstance[methodName].apply(pluginObj._objectInstance, args);\n  }\n}\nexport function getPlugin(pluginRef) {\n  if (typeof window !== 'undefined') {\n    return get(window, pluginRef);\n  }\n\n  return null;\n}\nexport function get(element, path) {\n  var paths = path.split('.');\n  var obj = element;\n\n  for (var i = 0; i < paths.length; i++) {\n    if (!obj) {\n      return null;\n    }\n\n    obj = obj[paths[i]];\n  }\n\n  return obj;\n}\nexport function pluginWarn(pluginName, plugin, method) {\n  if (method) {\n    console.warn('Native: tried calling ' + pluginName + '.' + method + ', but the ' + pluginName + ' plugin is not installed.');\n  } else {\n    console.warn(\"Native: tried accessing the \" + pluginName + \" plugin but it's not installed.\");\n  }\n\n  if (plugin) {\n    console.warn(\"Install the \" + pluginName + \" plugin: 'ionic cordova plugin add \" + plugin + \"'\");\n  }\n}\n/**\n * @private\n * @param pluginName\n * @param method\n */\n\nexport function cordovaWarn(pluginName, method) {\n  if (typeof process === 'undefined') {\n    if (method) {\n      console.warn('Native: tried calling ' + pluginName + '.' + method + ', but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');\n    } else {\n      console.warn('Native: tried accessing the ' + pluginName + ' plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator');\n    }\n  }\n}\n/**\n * @private\n */\n\nexport var wrap = function (pluginObj, methodName, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (opts.sync) {\n      // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is\n      return callCordovaPlugin(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return wrapObservable(pluginObj, methodName, args, opts);\n    } else if (opts.eventObservable && opts.event) {\n      return wrapEventObservable(opts.event, opts.element);\n    } else if (opts.otherPromise) {\n      return wrapOtherPromise(pluginObj, methodName, args, opts);\n    } else {\n      return wrapPromise(pluginObj, methodName, args, opts);\n    }\n  };\n};\n/**\n * @private\n */\n\nexport function wrapInstance(pluginObj, methodName, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (opts.sync) {\n      return callInstance(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return new Observable(function (observer) {\n        var pluginResult;\n\n        if (opts.destruct) {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return observer.next(args);\n          }, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return observer.error(args);\n          });\n        } else {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n        }\n\n        if (pluginResult && pluginResult.error) {\n          observer.error(pluginResult.error);\n        }\n\n        return function () {\n          try {\n            if (opts.clearWithArgs) {\n              return callInstance(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n            }\n\n            return callInstance(pluginObj, opts.clearFunction, []);\n          } catch (e) {\n            console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);\n            console.warn(e);\n          }\n        };\n      });\n    } else if (opts.otherPromise) {\n      return getPromise(function (resolve, reject) {\n        var result;\n\n        if (opts.destruct) {\n          result = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return resolve(args);\n          }, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return reject(args);\n          });\n        } else {\n          result = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n\n        if (result && result.then) {\n          result.then(resolve, reject);\n        } else {\n          reject();\n        }\n      });\n    } else {\n      var pluginResult_1, rej_1;\n      var p = getPromise(function (resolve, reject) {\n        if (opts.destruct) {\n          pluginResult_1 = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return resolve(args);\n          }, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return reject(args);\n          });\n        } else {\n          pluginResult_1 = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n\n        rej_1 = reject;\n      }); // Angular throws an error on unhandled rejection, but in this case we have already printed\n      // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n      // to error\n\n      if (pluginResult_1 && pluginResult_1.error) {\n        p.catch(function () {});\n        typeof rej_1 === 'function' && rej_1(pluginResult_1.error);\n      }\n\n      return p;\n    }\n  };\n}","map":{"version":3,"sources":["../../../../src/@ionic-native/core/decorators/common.ts"],"names":[],"mappings":"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","sourcesContent":["import { fromEvent, Observable } from 'rxjs';\n\nimport { CordovaOptions } from './interfaces';\n\ndeclare const window: any;\n\nexport const ERR_CORDOVA_NOT_AVAILABLE = { error: 'cordova_not_available' };\nexport const ERR_PLUGIN_NOT_INSTALLED = { error: 'plugin_not_installed' };\n\nexport function getPromise<T>(callback: (resolve: Function, reject?: Function) => any): Promise<T> {\n  const tryNativePromise = () => {\n    if (Promise) {\n      return new Promise<T>((resolve, reject) => {\n        callback(resolve, reject);\n      });\n    } else {\n      console.error(\n        'No Promise support or polyfill found. To enable Ionic Native support, please add the es6-promise polyfill before this script, or run with a library like Angular or on a recent browser.'\n      );\n    }\n  };\n\n  if (typeof window !== 'undefined' && window.angular) {\n    const doc = window.document;\n    const injector = window.angular.element(doc.querySelector('[ng-app]') || doc.body).injector();\n    if (injector) {\n      const $q = injector.get('$q');\n      return $q((resolve: Function, reject: Function) => {\n        callback(resolve, reject);\n      });\n    }\n    console.warn(\n      `Angular 1 was detected but $q couldn't be retrieved. This is usually when the app is not bootstrapped on the html or body tag. Falling back to native promises which won't trigger an automatic digest when promises resolve.`\n    );\n  }\n\n  return tryNativePromise();\n}\n\nexport function wrapPromise(pluginObj: any, methodName: string, args: any[], opts: CordovaOptions = {}) {\n  let pluginResult: any, rej: Function;\n  const p = getPromise((resolve: Function, reject: Function) => {\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        (...args: any[]) => resolve(args),\n        (...args: any[]) => reject(args)\n      );\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject);\n    }\n    rej = reject;\n  });\n  // Angular throws an error on unhandled rejection, but in this case we have already printed\n  // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n  // to error\n  if (pluginResult && pluginResult.error) {\n    p.catch(() => {});\n    typeof rej === 'function' && rej(pluginResult.error);\n  }\n  return p;\n}\n\nfunction wrapOtherPromise(pluginObj: any, methodName: string, args: any[], opts: any = {}) {\n  return getPromise((resolve: Function, reject: Function) => {\n    const pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);\n    if (pluginResult) {\n      if (pluginResult.error) {\n        reject(pluginResult.error);\n      } else if (pluginResult.then) {\n        pluginResult.then(resolve).catch(reject);\n      }\n    } else {\n      reject({ error: 'unexpected_error' });\n    }\n  });\n}\n\nfunction wrapObservable(pluginObj: any, methodName: string, args: any[], opts: any = {}) {\n  return new Observable(observer => {\n    let pluginResult;\n\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        (...args: any[]) => observer.next(args),\n        (...args: any[]) => observer.error(args)\n      );\n    } else {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        observer.next.bind(observer),\n        observer.error.bind(observer)\n      );\n    }\n\n    if (pluginResult && pluginResult.error) {\n      observer.error(pluginResult.error);\n      observer.complete();\n    }\n    return () => {\n      try {\n        if (opts.clearFunction) {\n          if (opts.clearWithArgs) {\n            return callCordovaPlugin(\n              pluginObj,\n              opts.clearFunction,\n              args,\n              opts,\n              observer.next.bind(observer),\n              observer.error.bind(observer)\n            );\n          }\n          return callCordovaPlugin(pluginObj, opts.clearFunction, []);\n        }\n      } catch (e) {\n        console.warn(\n          'Unable to clear the previous observable watch for',\n          pluginObj.constructor.getPluginName(),\n          methodName\n        );\n        console.warn(e);\n      }\n    };\n  });\n}\n\n/**\n * Wrap the event with an observable\n * @private\n * @param event event name\n * @param element The element to attach the event listener to\n * @returns {Observable}\n */\nfunction wrapEventObservable(event: string, element: any): Observable<any> {\n  element =\n    typeof window !== 'undefined' && element\n      ? get(window, element)\n      : element || (typeof window !== 'undefined' ? window : {});\n  return fromEvent(element, event);\n}\n\n/**\n * Checks if plugin/cordova is available\n * @return {boolean | { error: string } }\n * @private\n */\nexport function checkAvailability(\n  pluginRef: string,\n  methodName?: string,\n  pluginName?: string\n): boolean | { error: string };\nexport function checkAvailability(\n  pluginObj: any,\n  methodName?: string,\n  pluginName?: string\n): boolean | { error: string };\nexport function checkAvailability(plugin: any, methodName?: string, pluginName?: string): boolean | { error: string } {\n  let pluginRef, pluginInstance, pluginPackage;\n\n  if (typeof plugin === 'string') {\n    pluginRef = plugin;\n  } else {\n    pluginRef = plugin.constructor.getPluginRef();\n    pluginName = plugin.constructor.getPluginName();\n    pluginPackage = plugin.constructor.getPluginInstallName();\n  }\n\n  pluginInstance = getPlugin(pluginRef);\n\n  if (!pluginInstance || (!!methodName && typeof pluginInstance[methodName] === 'undefined')) {\n    if (typeof window === 'undefined' || !window.cordova) {\n      cordovaWarn(pluginName, methodName);\n      return ERR_CORDOVA_NOT_AVAILABLE;\n    }\n\n    pluginWarn(pluginName, pluginPackage, methodName);\n    return ERR_PLUGIN_NOT_INSTALLED;\n  }\n\n  return true;\n}\n\n/**\n * Checks if _objectInstance exists and has the method/property\n * @private\n */\nexport function instanceAvailability(pluginObj: any, methodName?: string): boolean {\n  return pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== 'undefined');\n}\n\nexport function setIndex(args: any[], opts: any = {}, resolve?: Function, reject?: Function): any {\n  // ignore resolve and reject in case sync\n  if (opts.sync) {\n    return args;\n  }\n\n  // If the plugin method expects myMethod(success, err, options)\n  if (opts.callbackOrder === 'reverse') {\n    // Get those arguments in the order [resolve, reject, ...restOfArgs]\n    args.unshift(reject);\n    args.unshift(resolve);\n  } else if (opts.callbackStyle === 'node') {\n    args.push((err: any, result: any) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  } else if (opts.callbackStyle === 'object' && opts.successName && opts.errorName) {\n    const obj: any = {};\n    obj[opts.successName] = resolve;\n    obj[opts.errorName] = reject;\n    args.push(obj);\n  } else if (typeof opts.successIndex !== 'undefined' || typeof opts.errorIndex !== 'undefined') {\n    const setSuccessIndex = () => {\n      // If we've specified a success/error index\n      if (opts.successIndex > args.length) {\n        args[opts.successIndex] = resolve;\n      } else {\n        args.splice(opts.successIndex, 0, resolve);\n      }\n    };\n\n    const setErrorIndex = () => {\n      // We don't want that the reject cb gets spliced into the position of an optional argument that has not been\n      // defined and thus causing non expected behavior.\n      if (opts.errorIndex > args.length) {\n        args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index\n      } else {\n        args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array\n      }\n    };\n\n    if (opts.successIndex > opts.errorIndex) {\n      setErrorIndex();\n      setSuccessIndex();\n    } else {\n      setSuccessIndex();\n      setErrorIndex();\n    }\n  } else {\n    // Otherwise, let's tack them on to the end of the argument list\n    // which is 90% of cases\n    args.push(resolve);\n    args.push(reject);\n  }\n  return args;\n}\n\nexport function callCordovaPlugin(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {},\n  resolve?: Function,\n  reject?: Function\n) {\n  // Try to figure out where the success/error callbacks need to be bound\n  // to our promise resolve/reject handlers.\n  args = setIndex(args, opts, resolve, reject);\n\n  const availabilityCheck = checkAvailability(pluginObj, methodName);\n\n  if (availabilityCheck === true) {\n    const pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());\n    return pluginInstance[methodName].apply(pluginInstance, args);\n  } else {\n    return availabilityCheck;\n  }\n}\n\nexport function callInstance(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {},\n  resolve?: Function,\n  reject?: Function\n) {\n  args = setIndex(args, opts, resolve, reject);\n\n  if (instanceAvailability(pluginObj, methodName)) {\n    return pluginObj._objectInstance[methodName].apply(pluginObj._objectInstance, args);\n  }\n}\n\nexport function getPlugin(pluginRef: string): any {\n  if (typeof window !== 'undefined') {\n    return get(window, pluginRef);\n  }\n  return null;\n}\n\nexport function get(element: Element | Window, path: string) {\n  const paths: string[] = path.split('.');\n  let obj: any = element;\n  for (let i = 0; i < paths.length; i++) {\n    if (!obj) {\n      return null;\n    }\n    obj = obj[paths[i]];\n  }\n  return obj;\n}\n\nexport function pluginWarn(pluginName: string, plugin?: string, method?: string): void {\n  if (method) {\n    console.warn(\n      'Native: tried calling ' + pluginName + '.' + method + ', but the ' + pluginName + ' plugin is not installed.'\n    );\n  } else {\n    console.warn(`Native: tried accessing the ${pluginName} plugin but it's not installed.`);\n  }\n  if (plugin) {\n    console.warn(`Install the ${pluginName} plugin: 'ionic cordova plugin add ${plugin}'`);\n  }\n}\n\n/**\n * @private\n * @param pluginName\n * @param method\n */\nexport function cordovaWarn(pluginName: string, method?: string): void {\n  if (typeof process === 'undefined') {\n    if (method) {\n      console.warn(\n        'Native: tried calling ' +\n          pluginName +\n          '.' +\n          method +\n          ', but Cordova is not available. Make sure to include cordova.js or run in a device/simulator'\n      );\n    } else {\n      console.warn(\n        'Native: tried accessing the ' +\n          pluginName +\n          ' plugin but Cordova is not available. Make sure to include cordova.js or run in a device/simulator'\n      );\n    }\n  }\n}\n\n// Fixes a bug in TypeScript 2.9.2 where the ...args is being converted into args: {} and\n// causing compilation issues\nexport type WrapFn = (...args: any[]) => any;\n\n/**\n * @private\n */\nexport const wrap = (pluginObj: any, methodName: string, opts: CordovaOptions = {}): WrapFn => {\n  return (...args: any[]) => {\n    if (opts.sync) {\n      // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is\n      return callCordovaPlugin(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return wrapObservable(pluginObj, methodName, args, opts);\n    } else if (opts.eventObservable && opts.event) {\n      return wrapEventObservable(opts.event, opts.element);\n    } else if (opts.otherPromise) {\n      return wrapOtherPromise(pluginObj, methodName, args, opts);\n    } else {\n      return wrapPromise(pluginObj, methodName, args, opts);\n    }\n  };\n};\n\n/**\n * @private\n */\nexport function wrapInstance(pluginObj: any, methodName: string, opts: any = {}): Function {\n  return (...args: any[]) => {\n    if (opts.sync) {\n      return callInstance(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return new Observable(observer => {\n        let pluginResult;\n\n        if (opts.destruct) {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => observer.next(args),\n            (...args: any[]) => observer.error(args)\n          );\n        } else {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            observer.next.bind(observer),\n            observer.error.bind(observer)\n          );\n        }\n\n        if (pluginResult && pluginResult.error) {\n          observer.error(pluginResult.error);\n        }\n\n        return () => {\n          try {\n            if (opts.clearWithArgs) {\n              return callInstance(\n                pluginObj,\n                opts.clearFunction,\n                args,\n                opts,\n                observer.next.bind(observer),\n                observer.error.bind(observer)\n              );\n            }\n            return callInstance(pluginObj, opts.clearFunction, []);\n          } catch (e) {\n            console.warn(\n              'Unable to clear the previous observable watch for',\n              pluginObj.constructor.getPluginName(),\n              methodName\n            );\n            console.warn(e);\n          }\n        };\n      });\n    } else if (opts.otherPromise) {\n      return getPromise((resolve: Function, reject: Function) => {\n        let result;\n        if (opts.destruct) {\n          result = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => resolve(args),\n            (...args: any[]) => reject(args)\n          );\n        } else {\n          result = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n        if (result && result.then) {\n          result.then(resolve, reject);\n        } else {\n          reject();\n        }\n      });\n    } else {\n      let pluginResult: any, rej: Function;\n      const p = getPromise((resolve: Function, reject: Function) => {\n        if (opts.destruct) {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => resolve(args),\n            (...args: any[]) => reject(args)\n          );\n        } else {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n        rej = reject;\n      });\n      // Angular throws an error on unhandled rejection, but in this case we have already printed\n      // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n      // to error\n      if (pluginResult && pluginResult.error) {\n        p.catch(() => {});\n        typeof rej === 'function' && rej(pluginResult.error);\n      }\n      return p;\n    }\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}