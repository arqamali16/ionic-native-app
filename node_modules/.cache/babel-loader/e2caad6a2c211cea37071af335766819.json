{"ast":null,"code":"import { Observable } from 'rxjs/Observable';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\nimport { checkReady } from './bootstrap';\nimport { cordovaWarn, getPlugin, getPromise, pluginWarn } from './util';\ncheckReady(); // declare const window;\n// declare var Promise;\n\nexport var ERR_CORDOVA_NOT_AVAILABLE = {\n  error: 'cordova_not_available'\n};\nexport var ERR_PLUGIN_NOT_INSTALLED = {\n  error: 'plugin_not_installed'\n};\nexport function checkAvailability(plugin, methodName, pluginName) {\n  var pluginRef, pluginInstance, pluginPackage;\n\n  if (typeof plugin === 'string') {\n    pluginRef = plugin;\n  } else {\n    pluginRef = plugin.constructor.getPluginRef();\n    pluginName = plugin.constructor.getPluginName();\n    pluginPackage = plugin.constructor.getPluginInstallName();\n  }\n\n  pluginInstance = getPlugin(pluginRef);\n\n  if (!pluginInstance || !!methodName && typeof pluginInstance[methodName] === 'undefined') {\n    if (!window.cordova) {\n      cordovaWarn(pluginName, methodName);\n      return ERR_CORDOVA_NOT_AVAILABLE;\n    }\n\n    pluginWarn(pluginName, pluginPackage, methodName);\n    return ERR_PLUGIN_NOT_INSTALLED;\n  }\n\n  return true;\n}\n/**\n * Checks if _objectInstance exists and has the method/property\n * @private\n */\n\nexport function instanceAvailability(pluginObj, methodName) {\n  return pluginObj._objectInstance && (!methodName || typeof pluginObj._objectInstance[methodName] !== 'undefined');\n}\n\nfunction setIndex(args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  } // ignore resolve and reject in case sync\n\n\n  if (opts.sync) {\n    return args;\n  } // If the plugin method expects myMethod(success, err, options)\n\n\n  if (opts.callbackOrder === 'reverse') {\n    // Get those arguments in the order [resolve, reject, ...restOfArgs]\n    args.unshift(reject);\n    args.unshift(resolve);\n  } else if (opts.callbackStyle === 'node') {\n    args.push(function (err, result) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  } else if (opts.callbackStyle === 'object' && opts.successName && opts.errorName) {\n    var obj = {};\n    obj[opts.successName] = resolve;\n    obj[opts.errorName] = reject;\n    args.push(obj);\n  } else if (typeof opts.successIndex !== 'undefined' || typeof opts.errorIndex !== 'undefined') {\n    var setSuccessIndex = function () {\n      // If we've specified a success/error index\n      if (opts.successIndex > args.length) {\n        args[opts.successIndex] = resolve;\n      } else {\n        args.splice(opts.successIndex, 0, resolve);\n      }\n    };\n\n    var setErrorIndex = function () {\n      // We don't want that the reject cb gets spliced into the position of an optional argument that has not been defined and thus causing non expected behaviour.\n      if (opts.errorIndex > args.length) {\n        args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index\n      } else {\n        args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array\n      }\n    };\n\n    if (opts.successIndex > opts.errorIndex) {\n      setErrorIndex();\n      setSuccessIndex();\n    } else {\n      setSuccessIndex();\n      setErrorIndex();\n    }\n  } else {\n    // Otherwise, let's tack them on to the end of the argument list\n    // which is 90% of cases\n    args.push(resolve);\n    args.push(reject);\n  }\n\n  return args;\n}\n\nfunction callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  } // Try to figure out where the success/error callbacks need to be bound\n  // to our promise resolve/reject handlers.\n\n\n  args = setIndex(args, opts, resolve, reject);\n  var availabilityCheck = checkAvailability(pluginObj, methodName);\n\n  if (availabilityCheck === true) {\n    var pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());\n    return pluginInstance[methodName].apply(pluginInstance, args);\n  } else {\n    return availabilityCheck;\n  }\n}\n\nfunction wrapPromise(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var pluginResult, rej;\n  var p = getPromise(function (resolve, reject) {\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return resolve(args);\n      }, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return reject(args);\n      });\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, resolve, reject);\n    }\n\n    rej = reject;\n  }); // Angular throws an error on unhandled rejection, but in this case we have already printed\n  // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n  // to error\n\n  if (pluginResult && pluginResult.error) {\n    p.catch(function () {});\n    typeof rej === 'function' && rej(pluginResult.error);\n  }\n\n  return p;\n}\n\nfunction wrapOtherPromise(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return getPromise(function (resolve, reject) {\n    var pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);\n\n    if (pluginResult) {\n      if (pluginResult.error) {\n        reject(pluginResult.error);\n      } else if (pluginResult.then) {\n        pluginResult.then(resolve).catch(reject);\n      }\n    } else {\n      reject({\n        error: 'unexpected_error'\n      });\n    }\n  });\n}\n\nfunction wrapObservable(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return new Observable(function (observer) {\n    var pluginResult;\n\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return observer.next(args);\n      }, function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return observer.error(args);\n      });\n    } else {\n      pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n    }\n\n    if (pluginResult && pluginResult.error) {\n      observer.error(pluginResult.error);\n      observer.complete();\n    }\n\n    return function () {\n      try {\n        if (opts.clearFunction) {\n          if (opts.clearWithArgs) {\n            return callCordovaPlugin(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n          }\n\n          return callCordovaPlugin(pluginObj, opts.clearFunction, []);\n        }\n      } catch (e) {\n        console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);\n        console.warn(e);\n      }\n    };\n  });\n}\n\nfunction callInstance(pluginObj, methodName, args, opts, resolve, reject) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  args = setIndex(args, opts, resolve, reject);\n\n  if (instanceAvailability(pluginObj, methodName)) {\n    return pluginObj._objectInstance[methodName].apply(pluginObj._objectInstance, args);\n  }\n}\n/**\n * Wrap the event with an observable\n * @private\n * @param event even name\n * @param element The element to attach the event listener to\n * @returns {Observable}\n */\n\n\nexport function wrapEventObservable(event, element) {\n  if (element === void 0) {\n    element = window;\n  }\n\n  return fromEvent(element, event);\n}\n/**\n * Certain plugins expect the user to override methods in the plugin. For example,\n * window.cordova.plugins.backgroundMode.onactivate = function() { ... }.\n *\n * Unfortunately, this is brittle and would be better wrapped as an Observable. overrideFunction\n * does just this.\n * @private\n */\n\nexport function overrideFunction(pluginObj, methodName, args, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return new Observable(function (observer) {\n    var availabilityCheck = checkAvailability(pluginObj, null, pluginObj.constructor.getPluginName());\n\n    if (availabilityCheck === true) {\n      var pluginInstance_1 = getPlugin(pluginObj.constructor.getPluginRef());\n      pluginInstance_1[methodName] = observer.next.bind(observer);\n      return function () {\n        return pluginInstance_1[methodName] = function () {};\n      };\n    } else {\n      observer.error(availabilityCheck);\n      observer.complete();\n    }\n  });\n}\n/**\n * @private\n */\n\nexport var wrap = function (pluginObj, methodName, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (opts.sync) {\n      // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is\n      return callCordovaPlugin(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return wrapObservable(pluginObj, methodName, args, opts);\n    } else if (opts.eventObservable && opts.event) {\n      return wrapEventObservable(opts.event, opts.element);\n    } else if (opts.otherPromise) {\n      return wrapOtherPromise(pluginObj, methodName, args, opts);\n    } else {\n      return wrapPromise(pluginObj, methodName, args, opts);\n    }\n  };\n};\n/**\n * @private\n */\n\nexport function wrapInstance(pluginObj, methodName, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (opts.sync) {\n      return callInstance(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return new Observable(function (observer) {\n        var pluginResult;\n\n        if (opts.destruct) {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return observer.next(args);\n          }, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return observer.error(args);\n          });\n        } else {\n          pluginResult = callInstance(pluginObj, methodName, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n        }\n\n        if (pluginResult && pluginResult.error) {\n          observer.error(pluginResult.error);\n          observer.complete();\n        }\n\n        return function () {\n          try {\n            if (opts.clearWithArgs) {\n              return callInstance(pluginObj, opts.clearFunction, args, opts, observer.next.bind(observer), observer.error.bind(observer));\n            }\n\n            return callInstance(pluginObj, opts.clearFunction, []);\n          } catch (e) {\n            console.warn('Unable to clear the previous observable watch for', pluginObj.constructor.getPluginName(), methodName);\n            console.warn(e);\n          }\n        };\n      });\n    } else if (opts.otherPromise) {\n      return getPromise(function (resolve, reject) {\n        var result;\n\n        if (opts.destruct) {\n          result = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return resolve(args);\n          }, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return reject(args);\n          });\n        } else {\n          result = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n\n        if (result && !!result.then) {\n          result.then(resolve, reject);\n        } else {\n          reject();\n        }\n      });\n    } else {\n      var pluginResult_1, rej_1;\n      var p = getPromise(function (resolve, reject) {\n        if (opts.destruct) {\n          pluginResult_1 = callInstance(pluginObj, methodName, args, opts, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return resolve(args);\n          }, function () {\n            var args = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n            }\n\n            return reject(args);\n          });\n        } else {\n          pluginResult_1 = callInstance(pluginObj, methodName, args, opts, resolve, reject);\n        }\n\n        rej_1 = reject;\n      }); // Angular throws an error on unhandled rejection, but in this case we have already printed\n      // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n      // to error\n\n      if (pluginResult_1 && pluginResult_1.error) {\n        p.catch(function () {});\n        typeof rej_1 === 'function' && rej_1(pluginResult_1.error);\n      }\n\n      return p;\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/@ionic-native/core/plugin.ts"],"names":[],"mappings":"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","sourcesContent":["import { Observable } from 'rxjs/Observable';\nimport { fromEvent } from 'rxjs/observable/fromEvent';\n\nimport { checkReady } from './bootstrap';\nimport { CordovaOptions } from './decorators';\nimport { cordovaWarn, getPlugin, getPromise, pluginWarn } from './util';\n\ncheckReady();\n\n// declare const window;\n// declare var Promise;\n\nexport const ERR_CORDOVA_NOT_AVAILABLE = { error: 'cordova_not_available' };\nexport const ERR_PLUGIN_NOT_INSTALLED = { error: 'plugin_not_installed' };\n\n/**\n * Checks if plugin/cordova is available\n * @return {boolean | { error: string } }\n * @private\n */\nexport function checkAvailability(\n  pluginRef: string,\n  methodName?: string,\n  pluginName?: string\n): boolean | { error: string };\nexport function checkAvailability(\n  pluginObj: any,\n  methodName?: string,\n  pluginName?: string\n): boolean | { error: string };\nexport function checkAvailability(\n  plugin: any,\n  methodName?: string,\n  pluginName?: string\n): boolean | { error: string } {\n  let pluginRef, pluginInstance, pluginPackage;\n\n  if (typeof plugin === 'string') {\n    pluginRef = plugin;\n  } else {\n    pluginRef = plugin.constructor.getPluginRef();\n    pluginName = plugin.constructor.getPluginName();\n    pluginPackage = plugin.constructor.getPluginInstallName();\n  }\n\n  pluginInstance = getPlugin(pluginRef);\n\n  if (\n    !pluginInstance ||\n    (!!methodName && typeof pluginInstance[methodName] === 'undefined')\n  ) {\n    if (!window.cordova) {\n      cordovaWarn(pluginName, methodName);\n      return ERR_CORDOVA_NOT_AVAILABLE;\n    }\n\n    pluginWarn(pluginName, pluginPackage, methodName);\n    return ERR_PLUGIN_NOT_INSTALLED;\n  }\n\n  return true;\n}\n\n/**\n * Checks if _objectInstance exists and has the method/property\n * @private\n */\nexport function instanceAvailability(\n  pluginObj: any,\n  methodName?: string\n): boolean {\n  return (\n    pluginObj._objectInstance &&\n    (!methodName ||\n      typeof pluginObj._objectInstance[methodName] !== 'undefined')\n  );\n}\n\nfunction setIndex(\n  args: any[],\n  opts: any = {},\n  resolve?: Function,\n  reject?: Function\n): any {\n  // ignore resolve and reject in case sync\n  if (opts.sync) {\n    return args;\n  }\n\n  // If the plugin method expects myMethod(success, err, options)\n  if (opts.callbackOrder === 'reverse') {\n    // Get those arguments in the order [resolve, reject, ...restOfArgs]\n    args.unshift(reject);\n    args.unshift(resolve);\n  } else if (opts.callbackStyle === 'node') {\n    args.push((err: any, result: any) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(result);\n      }\n    });\n  } else if (\n    opts.callbackStyle === 'object' &&\n    opts.successName &&\n    opts.errorName\n  ) {\n    const obj: any = {};\n    obj[opts.successName] = resolve;\n    obj[opts.errorName] = reject;\n    args.push(obj);\n  } else if (\n    typeof opts.successIndex !== 'undefined' ||\n    typeof opts.errorIndex !== 'undefined'\n  ) {\n    const setSuccessIndex = () => {\n      // If we've specified a success/error index\n      if (opts.successIndex > args.length) {\n        args[opts.successIndex] = resolve;\n      } else {\n        args.splice(opts.successIndex, 0, resolve);\n      }\n    };\n\n    const setErrorIndex = () => {\n      // We don't want that the reject cb gets spliced into the position of an optional argument that has not been defined and thus causing non expected behaviour.\n      if (opts.errorIndex > args.length) {\n        args[opts.errorIndex] = reject; // insert the reject fn at the correct specific index\n      } else {\n        args.splice(opts.errorIndex, 0, reject); // otherwise just splice it into the array\n      }\n    };\n\n    if (opts.successIndex > opts.errorIndex) {\n      setErrorIndex();\n      setSuccessIndex();\n    } else {\n      setSuccessIndex();\n      setErrorIndex();\n    }\n  } else {\n    // Otherwise, let's tack them on to the end of the argument list\n    // which is 90% of cases\n    args.push(resolve);\n    args.push(reject);\n  }\n  return args;\n}\n\nfunction callCordovaPlugin(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {},\n  resolve?: Function,\n  reject?: Function\n) {\n  // Try to figure out where the success/error callbacks need to be bound\n  // to our promise resolve/reject handlers.\n  args = setIndex(args, opts, resolve, reject);\n\n  const availabilityCheck = checkAvailability(pluginObj, methodName);\n\n  if (availabilityCheck === true) {\n    const pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());\n    return pluginInstance[methodName].apply(pluginInstance, args);\n  } else {\n    return availabilityCheck;\n  }\n}\n\nfunction wrapPromise(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {}\n) {\n  let pluginResult: any, rej: Function;\n  const p = getPromise((resolve: Function, reject: Function) => {\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        (...args: any[]) => resolve(args),\n        (...args: any[]) => reject(args)\n      );\n    } else {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        resolve,\n        reject\n      );\n    }\n    rej = reject;\n  });\n  // Angular throws an error on unhandled rejection, but in this case we have already printed\n  // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n  // to error\n  if (pluginResult && pluginResult.error) {\n    p.catch(() => {});\n    typeof rej === 'function' && rej(pluginResult.error);\n  }\n  return p;\n}\n\nfunction wrapOtherPromise(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {}\n) {\n  return getPromise((resolve: Function, reject: Function) => {\n    const pluginResult = callCordovaPlugin(pluginObj, methodName, args, opts);\n    if (pluginResult) {\n      if (pluginResult.error) {\n        reject(pluginResult.error);\n      } else if (pluginResult.then) {\n        pluginResult.then(resolve).catch(reject);\n      }\n    } else {\n      reject({ error: 'unexpected_error' });\n    }\n  });\n}\n\nfunction wrapObservable(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {}\n) {\n  return new Observable(observer => {\n    let pluginResult;\n\n    if (opts.destruct) {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        (...args: any[]) => observer.next(args),\n        (...args: any[]) => observer.error(args)\n      );\n    } else {\n      pluginResult = callCordovaPlugin(\n        pluginObj,\n        methodName,\n        args,\n        opts,\n        observer.next.bind(observer),\n        observer.error.bind(observer)\n      );\n    }\n\n    if (pluginResult && pluginResult.error) {\n      observer.error(pluginResult.error);\n      observer.complete();\n    }\n    return () => {\n      try {\n        if (opts.clearFunction) {\n          if (opts.clearWithArgs) {\n            return callCordovaPlugin(\n              pluginObj,\n              opts.clearFunction,\n              args,\n              opts,\n              observer.next.bind(observer),\n              observer.error.bind(observer)\n            );\n          }\n          return callCordovaPlugin(pluginObj, opts.clearFunction, []);\n        }\n      } catch (e) {\n        console.warn(\n          'Unable to clear the previous observable watch for',\n          pluginObj.constructor.getPluginName(),\n          methodName\n        );\n        console.warn(e);\n      }\n    };\n  });\n}\n\nfunction callInstance(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {},\n  resolve?: Function,\n  reject?: Function\n) {\n  args = setIndex(args, opts, resolve, reject);\n\n  if (instanceAvailability(pluginObj, methodName)) {\n    return pluginObj._objectInstance[methodName].apply(\n      pluginObj._objectInstance,\n      args\n    );\n  }\n}\n\n/**\n * Wrap the event with an observable\n * @private\n * @param event even name\n * @param element The element to attach the event listener to\n * @returns {Observable}\n */\nexport function wrapEventObservable(\n  event: string,\n  element: any = window\n): Observable<any> {\n  return fromEvent(element, event);\n}\n\n/**\n * Certain plugins expect the user to override methods in the plugin. For example,\n * window.cordova.plugins.backgroundMode.onactivate = function() { ... }.\n *\n * Unfortunately, this is brittle and would be better wrapped as an Observable. overrideFunction\n * does just this.\n * @private\n */\nexport function overrideFunction(\n  pluginObj: any,\n  methodName: string,\n  args: any[],\n  opts: any = {}\n): Observable<any> {\n  return new Observable(observer => {\n    const availabilityCheck = checkAvailability(\n      pluginObj,\n      null,\n      pluginObj.constructor.getPluginName()\n    );\n\n    if (availabilityCheck === true) {\n      const pluginInstance = getPlugin(pluginObj.constructor.getPluginRef());\n      pluginInstance[methodName] = observer.next.bind(observer);\n      return () => (pluginInstance[methodName] = () => {});\n    } else {\n      observer.error(availabilityCheck);\n      observer.complete();\n    }\n  });\n}\n\n/**\n * @private\n */\nexport const wrap = (\n  pluginObj: any,\n  methodName: string,\n  opts: CordovaOptions = {}\n) => {\n  return (...args: any[]) => {\n    if (opts.sync) {\n      // Sync doesn't wrap the plugin with a promise or observable, it returns the result as-is\n      return callCordovaPlugin(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return wrapObservable(pluginObj, methodName, args, opts);\n    } else if (opts.eventObservable && opts.event) {\n      return wrapEventObservable(opts.event, opts.element);\n    } else if (opts.otherPromise) {\n      return wrapOtherPromise(pluginObj, methodName, args, opts);\n    } else {\n      return wrapPromise(pluginObj, methodName, args, opts);\n    }\n  };\n};\n\n/**\n * @private\n */\nexport function wrapInstance(\n  pluginObj: any,\n  methodName: string,\n  opts: any = {}\n) {\n  return (...args: any[]) => {\n    if (opts.sync) {\n      return callInstance(pluginObj, methodName, args, opts);\n    } else if (opts.observable) {\n      return new Observable(observer => {\n        let pluginResult;\n\n        if (opts.destruct) {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => observer.next(args),\n            (...args: any[]) => observer.error(args)\n          );\n        } else {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            observer.next.bind(observer),\n            observer.error.bind(observer)\n          );\n        }\n\n        if (pluginResult && pluginResult.error) {\n          observer.error(pluginResult.error);\n          observer.complete();\n        }\n\n        return () => {\n          try {\n            if (opts.clearWithArgs) {\n              return callInstance(\n                pluginObj,\n                opts.clearFunction,\n                args,\n                opts,\n                observer.next.bind(observer),\n                observer.error.bind(observer)\n              );\n            }\n            return callInstance(pluginObj, opts.clearFunction, []);\n          } catch (e) {\n            console.warn(\n              'Unable to clear the previous observable watch for',\n              pluginObj.constructor.getPluginName(),\n              methodName\n            );\n            console.warn(e);\n          }\n        };\n      });\n    } else if (opts.otherPromise) {\n      return getPromise((resolve: Function, reject: Function) => {\n        let result;\n        if (opts.destruct) {\n          result = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => resolve(args),\n            (...args: any[]) => reject(args)\n          );\n        } else {\n          result = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            resolve,\n            reject\n          );\n        }\n        if (result && !!result.then) {\n          result.then(resolve, reject);\n        } else {\n          reject();\n        }\n      });\n    } else {\n      let pluginResult: any, rej: Function;\n      const p = getPromise((resolve: Function, reject: Function) => {\n        if (opts.destruct) {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            (...args: any[]) => resolve(args),\n            (...args: any[]) => reject(args)\n          );\n        } else {\n          pluginResult = callInstance(\n            pluginObj,\n            methodName,\n            args,\n            opts,\n            resolve,\n            reject\n          );\n        }\n        rej = reject;\n      });\n      // Angular throws an error on unhandled rejection, but in this case we have already printed\n      // a warning that Cordova is undefined or the plugin is uninstalled, so there is no reason\n      // to error\n      if (pluginResult && pluginResult.error) {\n        p.catch(() => {});\n        typeof rej === 'function' && rej(pluginResult.error);\n      }\n      return p;\n    }\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}